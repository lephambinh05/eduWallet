# üéØ T·∫°o Smart Contract v√† Thao t√°c t·ª´ Frontend

## üöÄ **B∆∞·ªõc 1: T·∫°o Smart Contract**

### **1.1 T·∫°o project Hardhat**
```bash
# T·∫°o th∆∞ m·ª•c m·ªõi
mkdir my-eduwallet-contract
cd my-eduwallet-contract

# Kh·ªüi t·∫°o npm project
npm init -y

# C√†i ƒë·∫∑t Hardhat
npm install --save-dev hardhat
npx hardhat init

# Ch·ªçn: Create a JavaScript project
```

### **1.2 C√†i ƒë·∫∑t dependencies**
```bash
# C√†i ƒë·∫∑t ethers v√† OpenZeppelin
npm install @openzeppelin/contracts
npm install dotenv
```

### **1.3 T·∫°o file .env**
```bash
# T·∫°o file .env
touch .env

# N·ªôi dung .env:
RPC_URL=https://rpc.zeroscan.org
PRIVATE_KEY=your_private_key_here
CONTRACT_ADDRESS=
```

### **1.4 T·∫°o Smart Contract**
```solidity
// contracts/EduWallet.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract EduWallet {
    // Struct cho h·ªçc b·∫°
    struct LearningRecord {
        uint256 id;
        string studentName;
        string courseName;
        uint256 score;
        address student;
        address issuer;
        uint256 timestamp;
        bool verified;
    }
    
    // Struct cho badge
    struct Badge {
        uint256 id;
        string name;
        string description;
        string imageHash;
        address student;
        uint256 earnedDate;
        bool active;
    }
    
    // Mappings
    mapping(uint256 => LearningRecord) public learningRecords;
    mapping(uint256 => Badge) public badges;
    mapping(address => uint256[]) public studentRecords;
    mapping(address => uint256[]) public studentBadges;
    
    // Counters
    uint256 public recordCount;
    uint256 public badgeCount;
    
    // Owner
    address public owner;
    
    // Events
    event LearningRecordAdded(uint256 indexed id, string studentName, address indexed student);
    event BadgeEarned(uint256 indexed id, string name, address indexed student);
    
    constructor() {
        owner = msg.sender;
    }
    
    // Th√™m h·ªçc b·∫°
    function addLearningRecord(
        string memory _studentName,
        string memory _courseName,
        uint256 _score,
        address _student
    ) public {
        recordCount++;
        
        learningRecords[recordCount] = LearningRecord({
            id: recordCount,
            studentName: _studentName,
            courseName: _courseName,
            score: _score,
            student: _student,
            issuer: msg.sender,
            timestamp: block.timestamp,
            verified: true
        });
        
        studentRecords[_student].push(recordCount);
        
        emit LearningRecordAdded(recordCount, _studentName, _student);
    }
    
    // T·∫°o badge
    function earnBadge(
        string memory _name,
        string memory _description,
        string memory _imageHash,
        address _student
    ) public {
        badgeCount++;
        
        badges[badgeCount] = Badge({
            id: badgeCount,
            name: _name,
            description: _description,
            imageHash: _imageHash,
            student: _student,
            earnedDate: block.timestamp,
            active: true
        });
        
        studentBadges[_student].push(badgeCount);
        
        emit BadgeEarned(badgeCount, _name, _student);
    }
    
    // L·∫•y h·ªçc b·∫°
    function getLearningRecord(uint256 _id) public view returns (
        uint256 id,
        string memory studentName,
        string memory courseName,
        uint256 score,
        address student,
        address issuer,
        uint256 timestamp,
        bool verified
    ) {
        LearningRecord memory record = learningRecords[_id];
        return (
            record.id,
            record.studentName,
            record.courseName,
            record.score,
            record.student,
            record.issuer,
            record.timestamp,
            record.verified
        );
    }
    
    // L·∫•y badge
    function getBadge(uint256 _id) public view returns (
        uint256 id,
        string memory name,
        string memory description,
        string memory imageHash,
        address student,
        uint256 earnedDate,
        bool active
    ) {
        Badge memory badge = badges[_id];
        return (
            badge.id,
            badge.name,
            badge.description,
            badge.imageHash,
            badge.student,
            badge.earnedDate,
            badge.active
        );
    }
    
    // L·∫•y h·ªçc b·∫° c·ªßa sinh vi√™n
    function getStudentRecords(address _student) public view returns (uint256[] memory) {
        return studentRecords[_student];
    }
    
    // L·∫•y badge c·ªßa sinh vi√™n
    function getStudentBadges(address _student) public view returns (uint256[] memory) {
        return studentBadges[_student];
    }
}
```

### **1.5 T·∫°o script deploy**
```javascript
// scripts/deploy.js
const hre = require("hardhat");

async function main() {
  console.log("üöÄ Deploying EduWallet contract...");
  
  const EduWallet = await hre.ethers.getContractFactory("EduWallet");
  const eduWallet = await EduWallet.deploy();
  
  await eduWallet.waitForDeployment();
  
  const contractAddress = await eduWallet.getAddress();
  
  console.log("‚úÖ Contract deployed to:", contractAddress);
  console.log("üìã Add this to your .env: CONTRACT_ADDRESS=" + contractAddress);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
```

### **1.6 Deploy contract**
```bash
# Compile
npx hardhat compile

# Deploy
npx hardhat run scripts/deploy.js --network pzo
```

## üé® **B∆∞·ªõc 2: T√≠ch h·ª£p v√†o Frontend**

### **2.1 C√†i ƒë·∫∑t dependencies cho frontend**
```bash
# V√†o th∆∞ m·ª•c frontend
cd src

# C√†i ƒë·∫∑t ethers
npm install ethers
```

### **2.2 T·∫°o service ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi contract**
```javascript
// src/services/contractService.js
import { ethers } from 'ethers';

class ContractService {
  constructor() {
    this.provider = null;
    this.signer = null;
    this.contract = null;
    this.contractAddress = process.env.REACT_APP_CONTRACT_ADDRESS;
    this.contractABI = [
      // Learning Records
      "function addLearningRecord(string memory _studentName, string memory _courseName, uint256 _score, address _student) public",
      "function getLearningRecord(uint256 _id) public view returns (uint256 id, string memory studentName, string memory courseName, uint256 score, address student, address issuer, uint256 timestamp, bool verified)",
      "function getStudentRecords(address _student) public view returns (uint256[] memory)",
      
      // Badges
      "function earnBadge(string memory _name, string memory _description, string memory _imageHash, address _student) public",
      "function getBadge(uint256 _id) public view returns (uint256 id, string memory name, string memory description, string memory imageHash, address student, uint256 earnedDate, bool active)",
      "function getStudentBadges(address _student) public view returns (uint256[] memory)",
      
      // Counts
      "function recordCount() public view returns (uint256)",
      "function badgeCount() public view returns (uint256)",
      
      // Events
      "event LearningRecordAdded(uint256 indexed id, string studentName, address indexed student)",
      "event BadgeEarned(uint256 indexed id, string name, address indexed student)"
    ];
  }

  // K·∫øt n·ªëi v·ªõi MetaMask
  async connectWallet() {
    if (typeof window.ethereum !== 'undefined') {
      try {
        // Y√™u c·∫ßu k·∫øt n·ªëi
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        // T·∫°o provider v√† signer
        this.provider = new ethers.BrowserProvider(window.ethereum);
        this.signer = await this.provider.getSigner();
        
        // T·∫°o contract instance
        this.contract = new ethers.Contract(
          this.contractAddress,
          this.contractABI,
          this.signer
        );
        
        console.log('‚úÖ Wallet connected:', await this.signer.getAddress());
        return true;
      } catch (error) {
        console.error('‚ùå Wallet connection failed:', error);
        return false;
      }
    } else {
      console.error('‚ùå MetaMask not installed');
      return false;
    }
  }

  // Th√™m h·ªçc b·∫°
  async addLearningRecord(studentName, courseName, score, studentAddress) {
    try {
      const tx = await this.contract.addLearningRecord(
        studentName,
        courseName,
        score,
        studentAddress
      );
      
      console.log('üìù Transaction sent:', tx.hash);
      
      const receipt = await tx.wait();
      console.log('‚úÖ Transaction confirmed:', receipt);
      
      return {
        success: true,
        txHash: tx.hash,
        receipt: receipt
      };
    } catch (error) {
      console.error('‚ùå Add learning record failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // T·∫°o badge
  async earnBadge(name, description, imageHash, studentAddress) {
    try {
      const tx = await this.contract.earnBadge(
        name,
        description,
        imageHash,
        studentAddress
      );
      
      console.log('üèÜ Transaction sent:', tx.hash);
      
      const receipt = await tx.wait();
      console.log('‚úÖ Transaction confirmed:', receipt);
      
      return {
        success: true,
        txHash: tx.hash,
        receipt: receipt
      };
    } catch (error) {
      console.error('‚ùå Earn badge failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // L·∫•y h·ªçc b·∫°
  async getLearningRecord(recordId) {
    try {
      const record = await this.contract.getLearningRecord(recordId);
      
      return {
        success: true,
        data: {
          id: record.id.toString(),
          studentName: record.studentName,
          courseName: record.courseName,
          score: record.score.toString(),
          student: record.student,
          issuer: record.issuer,
          timestamp: new Date(parseInt(record.timestamp.toString()) * 1000),
          verified: record.verified
        }
      };
    } catch (error) {
      console.error('‚ùå Get learning record failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // L·∫•y badge
  async getBadge(badgeId) {
    try {
      const badge = await this.contract.getBadge(badgeId);
      
      return {
        success: true,
        data: {
          id: badge.id.toString(),
          name: badge.name,
          description: badge.description,
          imageHash: badge.imageHash,
          student: badge.student,
          earnedDate: new Date(parseInt(badge.earnedDate.toString()) * 1000),
          active: badge.active
        }
      };
    } catch (error) {
      console.error('‚ùå Get badge failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // L·∫•y h·ªçc b·∫° c·ªßa sinh vi√™n
  async getStudentRecords(studentAddress) {
    try {
      const recordIds = await this.contract.getStudentRecords(studentAddress);
      
      const records = [];
      for (const id of recordIds) {
        const record = await this.getLearningRecord(id);
        if (record.success) {
          records.push(record.data);
        }
      }
      
      return {
        success: true,
        data: records
      };
    } catch (error) {
      console.error('‚ùå Get student records failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // L·∫•y badge c·ªßa sinh vi√™n
  async getStudentBadges(studentAddress) {
    try {
      const badgeIds = await this.contract.getStudentBadges(studentAddress);
      
      const badges = [];
      for (const id of badgeIds) {
        const badge = await this.getBadge(id);
        if (badge.success) {
          badges.push(badge.data);
        }
      }
      
      return {
        success: true,
        data: badges
      };
    } catch (error) {
      console.error('‚ùå Get student badges failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // L·∫•y ƒë·ªãa ch·ªâ v√≠ hi·ªán t·∫°i
  async getCurrentAddress() {
    if (this.signer) {
      return await this.signer.getAddress();
    }
    return null;
  }
}

export default new ContractService();
```

### **2.3 T·∫°o component ƒë·ªÉ thao t√°c**
```javascript
// src/components/ContractInteraction.js
import React, { useState, useEffect } from 'react';
import contractService from '../services/contractService';

const ContractInteraction = () => {
  const [connected, setConnected] = useState(false);
  const [currentAddress, setCurrentAddress] = useState('');
  const [loading, setLoading] = useState(false);
  const [records, setRecords] = useState([]);
  const [badges, setBadges] = useState([]);

  // Form states
  const [studentName, setStudentName] = useState('');
  const [courseName, setCourseName] = useState('');
  const [score, setScore] = useState('');
  const [badgeName, setBadgeName] = useState('');
  const [badgeDescription, setBadgeDescription] = useState('');

  // K·∫øt n·ªëi v√≠
  const connectWallet = async () => {
    setLoading(true);
    const success = await contractService.connectWallet();
    if (success) {
      setConnected(true);
      const address = await contractService.getCurrentAddress();
      setCurrentAddress(address);
      await loadData();
    }
    setLoading(false);
  };

  // Load d·ªØ li·ªáu
  const loadData = async () => {
    if (currentAddress) {
      const recordsResult = await contractService.getStudentRecords(currentAddress);
      const badgesResult = await contractService.getStudentBadges(currentAddress);
      
      if (recordsResult.success) {
        setRecords(recordsResult.data);
      }
      if (badgesResult.success) {
        setBadges(badgesResult.data);
      }
    }
  };

  // Th√™m h·ªçc b·∫°
  const addLearningRecord = async () => {
    if (!studentName || !courseName || !score) {
      alert('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin');
      return;
    }

    setLoading(true);
    const result = await contractService.addLearningRecord(
      studentName,
      courseName,
      parseInt(score),
      currentAddress
    );

    if (result.success) {
      alert('‚úÖ Th√™m h·ªçc b·∫° th√†nh c√¥ng!');
      setStudentName('');
      setCourseName('');
      setScore('');
      await loadData();
    } else {
      alert('‚ùå L·ªói: ' + result.error);
    }
    setLoading(false);
  };

  // T·∫°o badge
  const earnBadge = async () => {
    if (!badgeName || !badgeDescription) {
      alert('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin');
      return;
    }

    setLoading(true);
    const result = await contractService.earnBadge(
      badgeName,
      badgeDescription,
      '0x123...', // Image hash
      currentAddress
    );

    if (result.success) {
      alert('‚úÖ T·∫°o badge th√†nh c√¥ng!');
      setBadgeName('');
      setBadgeDescription('');
      await loadData();
    } else {
      alert('‚ùå L·ªói: ' + result.error);
    }
    setLoading(false);
  };

  return (
    <div style={{ padding: '20px', maxWidth: '800px', margin: '0 auto' }}>
      <h1>üéì EduWallet Smart Contract</h1>
      
      {!connected ? (
        <div>
          <p>K·∫øt n·ªëi v√≠ ƒë·ªÉ b·∫Øt ƒë·∫ßu:</p>
          <button 
            onClick={connectWallet}
            disabled={loading}
            style={{
              padding: '10px 20px',
              backgroundColor: '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '5px',
              cursor: 'pointer'
            }}
          >
            {loading ? 'ƒêang k·∫øt n·ªëi...' : 'K·∫øt n·ªëi MetaMask'}
          </button>
        </div>
      ) : (
        <div>
          <p>‚úÖ ƒê√£ k·∫øt n·ªëi: {currentAddress}</p>
          
          {/* Form th√™m h·ªçc b·∫° */}
          <div style={{ marginBottom: '30px', padding: '20px', border: '1px solid #ddd', borderRadius: '5px' }}>
            <h3>üìù Th√™m h·ªçc b·∫°</h3>
            <div style={{ marginBottom: '10px' }}>
              <input
                type="text"
                placeholder="T√™n sinh vi√™n"
                value={studentName}
                onChange={(e) => setStudentName(e.target.value)}
                style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
              />
              <input
                type="text"
                placeholder="T√™n kh√≥a h·ªçc"
                value={courseName}
                onChange={(e) => setCourseName(e.target.value)}
                style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
              />
              <input
                type="number"
                placeholder="ƒêi·ªÉm s·ªë"
                value={score}
                onChange={(e) => setScore(e.target.value)}
                style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
              />
              <button
                onClick={addLearningRecord}
                disabled={loading}
                style={{
                  padding: '10px 20px',
                  backgroundColor: '#28a745',
                  color: 'white',
                  border: 'none',
                  borderRadius: '5px',
                  cursor: 'pointer'
                }}
              >
                {loading ? 'ƒêang x·ª≠ l√Ω...' : 'Th√™m h·ªçc b·∫°'}
              </button>
            </div>
          </div>

          {/* Form t·∫°o badge */}
          <div style={{ marginBottom: '30px', padding: '20px', border: '1px solid #ddd', borderRadius: '5px' }}>
            <h3>üèÜ T·∫°o badge</h3>
            <div style={{ marginBottom: '10px' }}>
              <input
                type="text"
                placeholder="T√™n badge"
                value={badgeName}
                onChange={(e) => setBadgeName(e.target.value)}
                style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
              />
              <input
                type="text"
                placeholder="M√¥ t·∫£ badge"
                value={badgeDescription}
                onChange={(e) => setBadgeDescription(e.target.value)}
                style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
              />
              <button
                onClick={earnBadge}
                disabled={loading}
                style={{
                  padding: '10px 20px',
                  backgroundColor: '#ffc107',
                  color: 'black',
                  border: 'none',
                  borderRadius: '5px',
                  cursor: 'pointer'
                }}
              >
                {loading ? 'ƒêang x·ª≠ l√Ω...' : 'T·∫°o badge'}
              </button>
            </div>
          </div>

          {/* Hi·ªÉn th·ªã d·ªØ li·ªáu */}
          <div style={{ display: 'flex', gap: '20px' }}>
            <div style={{ flex: 1 }}>
              <h3>üìö H·ªçc b·∫° ({records.length})</h3>
              {records.map((record, index) => (
                <div key={index} style={{ padding: '10px', border: '1px solid #eee', marginBottom: '10px', borderRadius: '5px' }}>
                  <p><strong>{record.studentName}</strong></p>
                  <p>Kh√≥a h·ªçc: {record.courseName}</p>
                  <p>ƒêi·ªÉm: {record.score}</p>
                  <p>Ng√†y: {record.timestamp.toLocaleDateString()}</p>
                </div>
              ))}
            </div>
            
            <div style={{ flex: 1 }}>
              <h3>üèÜ Badge ({badges.length})</h3>
              {badges.map((badge, index) => (
                <div key={index} style={{ padding: '10px', border: '1px solid #eee', marginBottom: '10px', borderRadius: '5px' }}>
                  <p><strong>{badge.name}</strong></p>
                  <p>{badge.description}</p>
                  <p>Ng√†y nh·∫≠n: {badge.earnedDate.toLocaleDateString()}</p>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ContractInteraction;
```

### **2.4 Th√™m v√†o App.js**
```javascript
// src/App.js
import ContractInteraction from './components/ContractInteraction';

// Th√™m route m·ªõi
<Route path="/contract" element={<ContractInteraction />} />
```

### **2.5 T·∫°o file .env cho frontend**
```bash
# .env
REACT_APP_CONTRACT_ADDRESS=0x1234567890abcdef...
```

## üéØ **C√°ch s·ª≠ d·ª•ng:**

1. **Deploy contract** v·ªõi script tr√™n
2. **Copy contract address** v√†o .env
3. **Kh·ªüi ƒë·ªông frontend** v·ªõi component m·ªõi
4. **K·∫øt n·ªëi MetaMask** v√† b·∫Øt ƒë·∫ßu thao t√°c
5. **Th√™m h·ªçc b·∫°, t·∫°o badge** tr·ª±c ti·∫øp t·ª´ frontend

## üéâ **K·∫øt qu·∫£:**

- ‚úÖ Smart contract ƒë∆°n gi·∫£n, d·ªÖ hi·ªÉu
- ‚úÖ Frontend c√≥ th·ªÉ t∆∞∆°ng t√°c tr·ª±c ti·∫øp
- ‚úÖ D·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr√™n blockchain
- ‚úÖ C√≥ th·ªÉ verify t·ª´ b·∫•t k·ª≥ ƒë√¢u
- ‚úÖ Giao di·ªán th√¢n thi·ªán, d·ªÖ s·ª≠ d·ª•ng

**B√¢y gi·ªù b·∫°n c√≥ th·ªÉ t·∫°o v√† thao t√°c smart contract t·ª´ frontend!** üöÄ
